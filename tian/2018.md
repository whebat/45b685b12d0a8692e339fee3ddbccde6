## Question 1: MCQ

(1) &nbsp; What happens if you fail to use the delete operator after using the new operator?

(a) &nbsp; you get a dangling pointer  
(b) &nbsp; the program crashes  
(c) &nbsp; you get a memory leak  
(d) &nbsp; nothing, deleting data is optional in C++  
(e) &nbsp; none of the above

<details>
<summary>Answer</summary>
(c) &nbsp; you get a memory leak  
</details>

---

(2) &nbsp; Consider the following function prototype:

```cpp
int GetMark(const int &Result);
```

Which statement best describes the way data is being passed to the function?

(a) &nbsp; Result is passed by reference and its contents can be changed.  
(b) &nbsp; Result is passed by reference and its contents cannot be changed.  
(c) &nbsp; Result is passed by value and its contents can be changed.  
(d) &nbsp; Result is passed by value and its contents cannot be changed.  
(e) &nbsp; This is an illegal prototype.  

<details>
<summary>Answer</summary>
(b) &nbsp; Result is passed by reference and its contents cannot be changed.  
</details>

---

(3) &nbsp; The following code fragment is from the implementation of a linked list class:

```cpp
while(current->next != NULL)
    current = current->next;
current->next = newnode;
```

(a) &nbsp; adds a node to the head of a linked list.  
(b) &nbsp; adds a node to the tail of a linked list.  
(c) &nbsp; finds a specific node in a linked list.  
(d) &nbsp; destroys all nodes in a linked list.  
(e) &nbsp; makes a copy of a linked list.  

<details>
<summary>Answer</summary>
(b) &nbsp; adds a node to the tail of a linked list.  
</details>

---

(4) &nbsp; What will be printed by the following code fragment?

```cpp
int v = 123;
int *p = &v;
v = v + 2;
cout << *p
```

(a) &nbsp; Address of variable v  
(b) &nbsp; Address of variable p  
(c) &nbsp; 123  
(d) &nbsp; 125  
(e) &nbsp; None of the above  

<details>
<summary>Answer</summary>
(d) &nbsp; 125  
</details>

---

(5) &nbsp; State one advantage of using a doubly linked list for storing data items as opposed to using a singly linked list.

(a) &nbsp; less memory overheads  
(b) &nbsp; faster at finding data items  
(c) &nbsp; can be iterated in both directions  
(d) &nbsp; can store data of any type  
(e) &nbsp; can store twice as much data  

<details>
<summary>Answer</summary>
(c) &nbsp; can be iterated in both directions  
</details>

---

(6) &nbsp; Which of the following STL containers stores its data items contiguously (in adjacent memory locations)?

(a) &nbsp; vector  
(b) &nbsp; list  
(c) &nbsp; deque  
(d) &nbsp; set  
(e) &nbsp; map  

<details>
<summary>Answer</summary>
(a) &nbsp; vector  
</details>

---

(7) &nbsp; The correct statement for dynamically allocating an array of 10 characters is:

(a) &nbsp; `char A[10];`  
(b) &nbsp; `char A[] = "1234567890";`  
(c) &nbsp; `char A[11];`  
(d) &nbsp; `char *A = new char[10];`  
(e) &nbsp; `char *A = new char(10);`  

<details>
<summary>Answer</summary>
(d) &nbsp; <code>char *A = new char[10];</code>
</details>

---

(8) &nbsp; What will be printed by the following code fragment?

```cpp
class Point {
public:
    Point() { cout << "Constructor called"; }
};
int main()
{
    Point t1, *t2;
    return 0;
}
```


(a)
```txt
Constructor called
```
(b)  
```txt
Constructor called
Constructor called
```
(c) &nbsp; A compile error occurs  
(d) &nbsp; A runtime error occurs  
(e) &nbsp; None of the above  

<details>
<summary>Answer</summary>
(a) &nbsp; <code>Constructor called</code>
</details>

---

(9) &nbsp; The address of a struct instance be obtained by using:

(a) &nbsp; The `*` operator.  
(b) &nbsp; The `::` operator.  
(c) &nbsp; The `.` operator.  
(d) &nbsp; The `&` operator.  
(e) &nbsp; The `->` operator.

<details>
<summary>Answer</summary>
(d) &nbsp; The <code>&</code> operator.
</details>

---

(10) &nbsp; Assume class: `Aclass` is correctly defined, with public member functions:  
`void SetData(int); and int GetData();`  
Which statement is true about the following code fragment?
```cpp
AClass *MyClass;
MyClass.SetData();
int Tmp = MyClass.GetData();
```

(a) &nbsp; Nothing is wrong with the code fragment  
(b) &nbsp; The code fragment would give run time errors  
(c) &nbsp; The code fragment would give compile time errors  
(d) &nbsp; The code fragment would give link time errors  
(e) &nbsp; None of the above  

<details>
<summary>Answer</summary>
(c) &nbsp; The code fragment would give compile time errors  
</details>

## Question 2: Pointers and Dynamic Memory

### (a)
In relation to C++ programming:

(i) What does pointer dereferencing mean?
<details><summary>Attempt</summary>
TODO
</details>
<details><summary>GPT</summary>
Pointer dereferencing in C++ means accessing the value stored in the memory location pointed to by a pointer variable. The dereference operator * is used to retrieve the value at the memory location pointed to by the pointer.
</details>

(ii) What is a memory leak and how can this be prevented?
<details><summary>Attempt</summary>
TODO
</details>
<details><summary>GPT</summary>
A memory leak in C++ occurs when dynamically allocated memory is not properly deallocated or released when it is no longer needed, leading to a loss of memory resources. Memory leaks can lead to a program using up all available memory, causing it to crash or slow down significantly.
To prevent memory leaks, it is important to ensure that any memory allocated using the new operator is properly deallocated using the delete operator when it is no longer needed.
</details>

(iii) What happens when the new operator is unable to provide the amount of memory requested?
<details><summary>Attempt</summary>
TODO
</details><br />
<details><summary>GPT</summary>
When the new operator is unable to provide the amount of memory requested, it throws an exception of type std::bad_alloc. This can occur if the system is low on memory or if the requested amount of memory is too large to be allocated.
</details>

(vi) What is a void pointer and what can it be used for?
<details><summary>Attempt</summary>
TODO
</details>
<details><summary>GPT</summary>
A void pointer in C++ is a pointer that can point to any data type, but does not have a specific data type associated with it. It is declared using the void * syntax. Since a void pointer does not have a specific data type, it cannot be dereferenced directly, but must first be cast to a pointer of a specific data type.
Void pointers are often used in generic programming or when dealing with memory management, as they allow for more flexible and dynamic memory allocation and manipulation. However, they should be used with caution, as they can lead to type mismatches and memory access errors if not used properly.
</details>

